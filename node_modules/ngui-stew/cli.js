/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, xuewen.chu
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***** END LICENSE BLOCK ***** */

var util = require('./util');
var event = require('./event');
var { userAgent } = require('./request');
var net = require('net');
var http = require('http');
var https = require('https');
var { Notification } = require('./event');
var { URL } = require('./url');
var { Buffer } = require('buffer');
var errno = require('./errno');

var KEEP_ALIVE_TIME = 5e4;
var METHOD_CALL_TIMEOUT = 3e4; // 30s

/**
 * @class Conversation
 */
var Conversation = util.class('Conversation', {

	// @private:
	m_connect: false, // 是否尝试连接中
	m_is_open: false, // open status
	m_clients: null, // client list

	// @public:
	// @event:
	onOpen: null,
	onMessage: null,
	onError: null,
	onClose: null,

	/**
	 * @constructor
	 */
	constructor: function() {
		event.initEvents(this, 'Open', 'Message', 'Error', 'Close');
		
		var self = this;
		
		this.m_clients = {};
		
		this.onOpen.on(function() { // 握手成功连接已打开
			self.m_is_open = true;
			self.m_connect = false;
		});
		
		this.onClose.on(function() {
			self.m_is_open = false;
			self.m_connect = false;
		});
		
		this.onError.on(function(e) {
			self.m_connect = false;
		});
	},
	
	/**
	 * @get isOpen # 获取是否打开连接
	 */
	get isOpen() {
		return this.m_is_open;
	},
	
	/**
	 * @fun bindClient # 绑定
	 * @arg client {Client}
	 */
	bindClient: function(client) {
		var name = client.name;
		var clients = this.m_clients;
		if (name in clients) {
			throw new Error('No need to repeat binding');
		} else {
			clients[name] = client;
			if (this.m_is_open) {
				this.send({ type: 'bind_client_service', name: name });
			}
			else {
				util.nextTick(this, this.connect); // 还没有打开连接,下一帧开始尝试连接
			}
		}
	},
	
	/**
	 * @get clients # 获取绑定的Client列表
	 */
	get clients() {
		return this.m_clients;
	},
	
	/**
	 * @fun connect # connercion server
	 */
	connect: function() {
		if (!this.m_is_open && !this.m_connect) {
			for (var i in this.m_clients) {
				this.m_connect = true;
				this.initialize();
				return;
			}
			// 连接必需要绑定服务才能使用
			throw new Error('connection must bind service');
		}
	},
	
	/**
	 * @fun parse # parser message
	 * @arg msg {String}
	 */
	parse: function(msg) {
		if (msg != '\ufffb\ubfff') { // 这是ping数据无需理会
			var data = JSON.parse(msg);
			var client = this.m_clients[data.service];
			if (client) {
				client.receiveMessage(data);
			} else {
				console.error('Could not find the message handler, '+
											'discarding the message, ' + data.service);
			}
			this.onMessage.trigger(data);
		}
	},
	
	/**
	 * @fun init # init conversation
	 */
	initialize: function() {},
	
	/**
	 * @fun close # close conversation connection
	 */
	close: function() {},
	
	/**
	 * @fun send # send message to server
	 * @arg [data] {Object}
	 */
	send: function(data) {},

	/**
	 * @func ping()
	 */
	ping: function() { },

	// @end

});

/**
 * @class WSParser
 */
var WSParser = util.class('WSParser', {
	// @public:

	buffer: null,
	i: 0,
	
	constructor: function() {
		event.initEvents(this, 'Close', 'Data', 'Error');
		this.buffer = Buffer.alloc(0);
	},
	
	add: function(data) {
		this.buffer = Buffer.concat([this.buffer, data]);
		this.parse();
	},
	
	parse: function() {
		var chr, len = this.buffer.length;
		for (var i = this.i; i < len; i++) {
			this.i = i;
			chr = this.buffer[i];
			
			if (i === 0) {
				if (chr != 0x0)
					this.error('Bad framing. Expected null byte as first frame');
				else 
					continue;
			}
			if (chr == 0xff) {
				var buffer = this.buffer.slice(1, i);
				this.onData.trigger(buffer);
				this.buffer = this.buffer.slice(i + 1);
				this.i = 0;
				this.parse();
				return;
			}
		}
	},
	
	error: function(reason) {
		this.buffer = Buffer.alloc(0);
		this.i = 0;
		this.onError.trigger(reason);
		return this;
	},

	// @end
});

/**
 * @class WSConversation
 */
var WSConversation = util.class('WSConversation', Conversation, {

	// @private:
	m_wsreq: null,
	m_socket: null, // web socket connection
	m_url: null,
	m_message: null,

	/**
	 * @get url
	 */
	get url() { return this.m_url },
	
	// @public:
	/**
	 * @constructor
	 * @arg path {String} ws://192.168.1.101:8091/
	 */
	constructor: function(path) {
		Conversation.call(this);
		this.m_message = [];
		path = path || util.config.web_service || 'ws://localhost';
		util.assert(path, 'Server path is not correct');
		path = util.resolve(path);
		this.m_url = new URL(path.replace(/^http/, 'ws'));
	},
	
	/** 
	 * @ovrewrite 
	 */
	initialize: function() {
		util.assert(!this.m_wsreq, 'No need to repeat open');
		var self = this;
		var url = this.m_url;
		var bind_client_services = Object.keys(this.clients).join(',');

		url.setParam('bind_client_services', bind_client_services);

		var isSSL = url.protocol == 'wss:';
		var port = url.port || (isSSL ? 443: 80);
		var lib = isSSL ? https: http;
		var path = url.path;

		var options = {
			hostname: url.hostname,
			port: port,
			path: path,
			headers: {
				'User-Agent': userAgent,
				'Connection': 'Upgrade',
				'Upgrade': 'websocket',
			},
			rejectUnauthorized: false
		};

		if (isSSL) {
			options.agent = new https.Agent(options);
		}

		var req = this.m_wsreq = lib.request(options);

		req.on('upgrade', function(res, socket, upgradeHead) {
			self.m_socket = socket;
			var parser = new WSParser();

			socket.setTimeout(0);
			socket.setKeepAlive(true, KEEP_ALIVE_TIME);
			
			socket.on('timeout', e=>self.close());
			socket.on('end', e=>self.close());
			socket.on('close', e=>self.close());

			socket.on('error', function(e) {
				// console.error(e);
				self.onError.trigger(e);
				var socket = this.m_socket;
				self.close();
				if (socket) 
					socket.destroy();
			});
			
			socket.on('data', d=>parser.add(d));

			parser.onData.on(e=>self.parse(e.data.toString('utf-8')));
			parser.onClose.on(e=>self.close());

			parser.onError.on(function(e) {
				console.error(e.data);
				self.onError.trigger(e.data);
				self.close();
			});

			var message = self.m_message;
			self.m_message = [];
			self.onOpen.trigger();

			message.forEach(m=>socket.write(m, 'utf-8'));
		});

		req.on('error', function(e) {
			self.m_wsreq = null;
			self.onError.trigger(e);
			self.close();
		});

		req.end();
	},
	
	/** 
	 * @ovrewrite 
	 */
	close: function() {
		if (this.isOpen) {
			var socket = this.m_socket;
			this.m_wsreq = null;
			this.m_socket = null;
			socket.removeAllListeners('end');
			socket.removeAllListeners('close');
			socket.removeAllListeners('error');
			socket.removeAllListeners('data');
			socket.end();
			this.onClose.trigger();
		}
	},
	
	/**
	 * @ovrewrite 
	 */
	send: function(msg) {
		msg = '\u0000' + JSON.stringify(msg) + '\ufffd';
		if (this.isOpen) {
			this.m_socket.write(msg, 'utf-8');
		} else {
			this.m_message.push(msg);
			this.connect(); // 尝试连接
		}
	},

	/**
	 * @ovrewrite 
	 */
	ping: function() {
		if (this.isOpen) {
			this.m_socket.write('\u0000\ufffb\ubfff\ufffd', 'utf-8');
		} else {
			this.connect(); // 尝试连接
		}
	},
	
});

/**
 * @class Client
 */
var Client = util.class('Client', Notification, {
	// @private:
	m_callbacks: null,
	m_service_name: '',
	m_conv: null,   // conversation

	// @public:
	/**
	 * @get name
	 */
	get name() {
		return this.m_service_name;
	},

	/**
	 * @get conv
	 */	
	get conv() {
		return this.m_conv;
	},
	
	/**
	 * @constructor constructor(service_name, conv)
	 */
	constructor: function(service_name, conv) {
		this.m_callbacks = {};
		this.m_service_name = service_name;
		this.m_conv = conv || new WSConversation();

		util.assert(service_name);
		util.assert(this.m_conv);

		conv.onClose.on(e=>{
			var callbacks = this.m_callbacks;
			this.m_callbacks = {};
			var err = Error.new(errno.ERR_CONNECTION_DISCONNECTION);
			for (var i in callbacks) {
				callbacks[i].err(err);
			}
		});

		this.m_conv.bindClient(this);
	},

	/**
	 * @func receiveMessage(data)
	 */
	receiveMessage: function(data) {
		if (data.type == 'callback') {
			var cb = this.m_callbacks[data.callback];
			delete this.m_callbacks[data.callback];
			if (cb) {
				if (data.error) { // throw error
					cb.err(Error.new(data.error));
				} else {
					cb.ok(data.data);
				}
			} else {
				console.error('Unable to callback, no callback context can be found');
			}
		} else if (data.type == 'event') {
			this.trigger(data.name, data.data);
		} else {
			// TODO ...
		}
	},

	/**
	 * @func call(name, data)
	 */
	call: function(name, data) {
		return new Promise((resolve, reject)=>{
			var id = util.id;
			var timeid = setTimeout(e=>{
				reject(Error.new(errno.ERR_METHOD_CALL_TIMEOUT));
			}, exports.METHOD_CALL_TIMEOUT);

			this.m_callbacks[id] = { 
				id: id, 
				ok: (e)=>{
					clearTimeout(timeid);
					resolve(e);
				},
				err: (e)=>{
					clearTimeout(timeid);
					reject(e);
				},
			};

			this.m_conv.send({ 
				service: this.name, 
				type: 'call', 
				name: name, 
				data: data, 
				callback: id,
			});
		});
	},

	/**
	 * @func send(name, data) no callback, no return data
	 */
	send: function(name, data) {
		this.m_conv.send({ 
			service: this.name, 
			type: 'call', 
			name: name, 
			data: data,
		});
	},

});

exports = module.exports = {
	METHOD_CALL_TIMEOUT: METHOD_CALL_TIMEOUT,
	Conversation: Conversation,
	WSConversation: WSConversation,
	Client: Client,
};
