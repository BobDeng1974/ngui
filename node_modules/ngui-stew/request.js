
var http = require('http');
var https = require('https');
var url = require('url');
var util = require('./util');
var user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) \
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36';
var Buffer = require('buffer').Buffer;
var querystring = require('querystring');
var shared = null;

class CacheData {

	constructor() {
		this.m_getscache = {};
	}

	has(key) {
		return name in this.m_getscache;
	}

	get(key) {
		var i = this.m_getscache[key];
		return i ? i.data : null;
	}

	set(key, data, cacheTiem) {
		var i = this.m_getscache[key];
		if (i) {
			var id = i.timeoutid;
			if (id) {
				clearTimeout(id);
			}
		}
		this.m_getscache[key] = {
			data: data,
			timeoutid: cacheTiem ? setTimeout(e=>{
				delete this.m_getscache[key];
			}, cacheTiem): 0,
		}
	}

	static hash(object) {
		return util.hash(JSON.stringify(object));
	}

}

class Request {

	constructor(serverURL, mock, mockSwitch) {
		this.m_user_agent = user_agent;
		this.m_server_url = serverURL || util.config.web_service || 'http://localhost';
		this.m_mock = mock || {};
		this.m_mock_switch = mockSwitch;
		this.m_urlencoded = true;
		this.m_enable_strict_response_data = false;
		this.m_cache = new CacheData();
	}

	get userAgent() { return this.m_user_agent }
	set userAgent(v) { this.m_user_agent = v }
	get urlencoded() { return this.m_urlencoded }
	set urlencoded(v) { this.m_urlencoded = v }
	get serverURL() { return this.m_server_url }
	set serverURL(v) { this.m_server_url = v }
	get mock() { return this.m_mock }
	set mock(v) { this.m_mock = v }
	get mockSwitch() { return this.m_mock_switch }
	set mockSwitch(v) { this.m_mock_switch = v }
	get enableStrictResponseData() { return this.m_enable_strict_response_data }
	set enableStrictResponseData(value) { this.m_enable_strict_response_data = value }

	parseResponseData(buf) {
		var json = buf.toString('utf8');
		var res = JSON.parse(json);
		if (this.m_enable_strict_response_data) {
			if (res.code === 0) {
				return res.data;
			} else {
				throw Error.new(res, res.code);
			}
		} else {
			return res;
		}
	}

	request(name, method, params, Headers) {
		return new Promise((resolve, reject)=> {
			params = params || '';
			Headers = Headers || {}

			if (this.m_mock[name] && (!this.m_mock_switch || this.m_mock_switch[name])) {
				process.nextTick(()=> {
					resolve({...this.m_mock[name]});
				});
			} else {
				var uri = url.parse(this.m_server_url + '/' + name);
				var is_https = uri.protocol == 'https:';
				var lib =	is_https ? https: http;
				var port = Number(uri.port) || (is_https ? 443: 80);
				var path = uri.path;
				var headers = {
					'User-Agent': this.m_user_agent,
					'Accept': 'application/json',
					...Headers,
				};
				var post_data = null;

				if (method == 'GET') {
					if (params) {
						path += (uri.search ? '&' : '?') + querystring.stringify(params);
					}
				} else {
					if (this.m_urlencoded) {
						headers['Content-Type'] = 'application/x-www-form-urlencoded';
						if (params) {
							post_data = querystring.stringify(params);
						}
					} else {
						headers['Content-Type'] = 'application/json';
						if (params) {
							post_data = JSON.stringify(params);
						}
					}
					headers['Content-Length'] = post_data ? Buffer.byteLength(post_data) : 0;
				}

				var options = {
					hostname: uri.hostname,
					port: port,
					path: path,
					method: method,
					headers: headers,
					rejectUnauthorized: false
				};
				
				if (is_https) {
					options.agent = new https.Agent(options);
				}

				var req = lib.request(options, (res)=> {
					// console.log(`STATUS: ${res.statusCode}`);
					// console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
					// res.setEncoding('utf8');
					var data = null;
					res.on('data', (chunk)=> {
						// console.log(`BODY: ${chunk}`);
						if (data) {
							data = Buffer.concat([data, chunk]);
						} else {
							data = chunk;
						}
					});
					res.on('end', ()=> {
						// console.log('No more data in response.');
						try {
							resolve(this.parseResponseData(data));
						} catch(e) {
							e.description = data.toString('utf-8');
							reject(e);
						}
					});
				});

				req.on('error', (e)=> {
					// console.error(`problem with request: ${e.message}`);
					reject(e);
				});

				// write data to request body
				if (method == 'POST') {
					if (post_data)
						req.write(post_data);
				}
				req.end();
			}
		});
	}

	get(name, params, headers, cacheTime = 0) {
		if (typeof headers == 'number') {
			cacheTime = headers;
			headers = {};
		}
		if (cacheTime) {
			var key = CacheData.hash({ name: name, params: params });
			var data = this.m_cache.get(key);
			if (data) {
				return data;
			}
			data = this.request(name, 'GET', params, headers);
			this.m_cache.set(key, data, cacheTime);
			return data;
		} else {
			return this.request(name, 'GET', params, headers);
		}
	}

	post(name, params, headers) {
		return this.request(name, 'POST', params, headers);
	}
	
	call(name, params, headers) {
		return this.post(name, params, headers);
	}
}

module.exports = {
	
	Request: Request,

	/**
	 * @get userAgent
	 */
	get userAgent() {
		return user_agent;
	},

	/**
	 * @func setShared
	 */
	setShared: function(req) {
		shared = req;
	},

	/**
	 * @get shared # default web server
	 */
	get shared() {
		return shared;
	},

	request: async function(name, method, params, headers) {
		return await shared.request(name, method, params, headers)
	},
	get: async function(name, params, headers, cacheTime = 0) {
		return await shared.get(name, params, headers, cacheTime)
	},
	post: async function(name, params, headers) {
		return await shared.post(name, params, headers)
	}, 
};
