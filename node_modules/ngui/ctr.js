/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright © 2015-2016, xuewen.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of xuewen.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL xuewen.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

import './util';
import { EventNoticer, NativeNotification } from './event';

var ngui = process.binding('ngui');
var View = ngui.View;
var Text = ngui.Text;

function reset_data_bind_attrs(host /*View or ViewController*/ ) {
  if (host.__bind) {
    host.__bind.attrs = [];
  }
}

function unregister_data_bind(self, id, obj) {
  delete obj.__bind_id;
  self.onViewDataChange.off(id);
}

function register_view_data_bind(self, view) {
  if ( view.__bind_id ) return;
  
  var id = util.id();
  view.__bind_id = id;

  if ( !view.__bind ) {
    view.__bind = {
      attrs: [ /* attr_vx [names,type,value] */ ], 
      replace: null,
      /*{
        mode: 0,  // mode: 0 inner text | 1 view | 2 ctr.view
        view_xml: null, // view xml data
      }*/
    };
  }
  
  view.onRemoveView.once(function() {
    unregister_data_bind(self, id, view);
  });
  
  self.onViewDataChange.on2(function(view) {
    var bind = view.__bind;
    var replace = bind.replace;
    
    if (replace) { // full bind
      var view_xml = replace.view_xml;
      var exec = view_xml[1];

      if (replace.mode == 1) { // replace view
        var { next, parent } = view;
        view.remove(); // Delete first Avoid ID repeats
        load_child_view_from_bind_data_vx(self, parent, next, view_xml);

      } else if (replace.mode == 2) { // replace ctr.view
        var vx2 = exec(self.m_vdata, self); // 数据绑定返回的数据必须都为元数据
        var [type,tag] = vx2;
        util.assert(type === 0);
        let view = new tag();
        self.view = view;
        load_view(self, view, value);
        register_view_data_bind_with_replace(self, view, 2, view_xml); // 

      } else { // replace inner text string
        view.innerText = exec(self.m_vdata, self);
      }
    } else { // attributes bind
      bind.attrs.forEach(function(attr_vx) {
        var [names,type,exec] = attr_vx;
        var len = names.length - 1;
        var name = names[len];
        var target = view;
        for (var i = 0; i < len; i++) {
          target = target[names[i]];
        }
        target[name] = exec(self.m_vdata, self);
      });
    }
  }, view, id);
}

function register_subctr_data_bind(self, subctr) {
  if ( subctr._bind_id ) return;

  var id = util.id();
  subctr.__bind_id = id;

  if ( !subctr.__bind ) {
    subctr.__bind = {
      attrs: [ /* attr vx [names,type,value] */ ], 
      replace: null, // { view_xml: null, /* view xml data */ }
    };
  }

  // listener view data change event
  self.onViewDataChange.on2(function(subctr) {
    var view = subctr.view; // 没有视图的控制器无效
    if (view && subctr.parent !== self) {
      var bind = subctr.__bind;
      var replace = bind.replace;

      if (replace) {
        var { next, parent } = view;
        view.remove(); // 删除这个视图,原控制器也会失效
        load_child_view_from_bind_data_vx(self, parent, next, replace.view_xml);

      } else {
        // set view controller attributes
        bind.attrs.forEach(function(item) {
          var [names,type,exec] = attr_vx;
          var len = names.length - 1;
          var name = names[len];
          var target = subctr;
          for (var i = 0; i < len; i++) {
            target = target[names[i]];
          }
          target[name] = exec(self.m_vdata, self);
        });
      }
    } else { // delete data bind
      unregister_data_bind(self, id, subctr);
    }
  }, subctr, id);
}

function register_view_data_bind_with_replace(self, view, replace_mode, vx) {
  register_view_data_bind(self, view);
  view.__bind.replace = { mode: mode, view_xml: vx };
}

function register_subctr_data_bind_with_replace(self, subctr, vx) {
  register_subctr_data_bind(self, subctr);
  view.__bind.replace = { view_xml: vx };
}

function set_attrbute(self, obj, attr_vx, init_data_bind) {
  // [names,type,value]
  var [names,type,value,multiple] = attr_vx;
  var target = obj;
  var len = names.length - 1;
  var name = names[len];
  
  for (var i = 0; i < len; i++) {
    target = target[names[i]];
  }
  if (type === 0)  {
    target[name] = value;
  } else if (type == 3) { // data bind
    target[name] = value(self.m_vdata, self);
    if (multiple) { // multiple bind
      add_data_bind(self, obj);
      obj.__bind.attrs.push(attr_vx);
    }
  } else {
    throw new TypeError('Unknown view xml attribute type');
  }
}

function load_child_view_from_bind_data_vx(self, parent, next, raw_bind_data_vx) {
  // The data returned from the data binding must all be metadata
  var [type,exec] = raw_bind_data_vx;
  var vx = exec(self.m_vdata, self); // 数据绑定返回的数据必须都为元数据，即类型为0的vx数据

  if (Array.isArray(vx) && vx[0] === 0) { // tag
    var tag = vx[1];
    var obj = new tag();
    if (obj instanceof ViewController) { // ctr
      load_subctr(self, obj, vx, parent, next);
      register_subctr_data_bind_with_replace(self, obj, raw_bind_data_vx);
    } else { // view
      if (next) {
        next.before(obj);
      } else {
        obj.appendTo(parent);
      }
      load_view(self, obj, vx);
      register_view_data_bind_with_replace(self, obj, 1, raw_bind_data_vx); 
    }
  } else { // string append text
    var view = parent.appendText(vx);
    if (view) {
      if ( next ) {
        next.before(view); // Right position
      }
      register_view_data_bind_with_replace(self, view, 1, raw_bind_data_vx);
    } else { // replace inner text
      register_view_data_bind_with_replace(self, parent, 0, raw_bind_data_vx); 
    }
  }
}

function load_child_view(self, parent, next, vx) {
  if (Array.isArray(vx)) { 
    var [type,value] = vx;

    if (type === 0) { // tag
      var obj = new value();
      if (obj instanceof ViewController) { // ctr
        load_subctr(self, obj, vx, parent, next);
      } else { // view
        if (next) {
          next.before(obj);
        } else {
          obj.appendTo(parent);
        }
        load_view(self, obj, vx);
      }
      return;
    } else if (type == 1) {
      throw new TypeError('Unimplemented <prefix:suffix />');
    } else if (type == 2) {
      vx = value;
    }
  } // else string append text

  var view = parent.appendText(vx);
  if (view) {
    if ( next ) {
      next.before(view); // Right position
    }
  }
}

// empty view xml
export const EMPTY_VIEW_XML = [0,View,[],[]];

// Is empty view xml
export function isEmptyViewXml(vx) {
  return vx === EMPTY_VIEW_XML;
}

 /**
  * @func isViewXml(vx[,type])
  * @arg vx {Object}
  * @arg [type] {class}
  * @ret {[`bool`]}
  */
export function isViewXml(vx, type) {
  // [0,tag,[attrs],[child],vdata] 
  if (Array.isArray(vx) && vx[0] === 0) {
    var tag = vx[1];
    if ( tag ) {
      if ( type ) {
        return util.equalsClass(type, tag);
      } else {
        return true;
      }
    }
  }
  return false;
}

function load_subctr(self, subctr, vx, parent, next) {
  var [,,attrs,childs,vdata] = vx;
  
  reset_data_bind_attrs(subctr);
  
  if (vdata) {
    set_attrbute(self, subctr, vdata, register_subctr_data_bind);
  }
  
  if (childs.length) {
    subctr.loadView(...childs);
  } else {
    subctr.loadView(EMPTY_VIEW_XML);
  }
  
  var view = subctr.view;
  
  if (!view) {
    subctr.view = view = new View();
  }
  if (next) {
    next.before(view);
  } else {
    view.appendTo(parent);
  }
  
  for (var attr of attrs) {
    set_attrbute(self, subctr, attr, register_subctr_data_bind);
  }
}

function load_view(self, view, vx) {
  var [,,attrs,childs] = vx;

  reset_data_bind_attrs(view);

  // View xml data format info
  // [0,tag,[attrs],[child],vdata]              <tag />
  // [1,prefix,suffix,[attrs],[child],vdata]    <prefix:suffix />
  // [2,String]                                 string
  // [3,BindFunc,multiple]                      %{xx} or %%{xx}
  // [4,value]                                  ${xx}

  for (var ch of childs) {
    switch (ch[0]) {
      case 0: // <tag />
        let tag = ch[1];
        let obj = new tag();
        if (obj instanceof ViewController) {
          load_subctr(self, obj, ch, view, null);
        } else { // view
          obj.appendTo(view);
          load_view(self, obj, ch);
        }
        break;
      case 1: // <prefix:suffix />
        throw new Error('Unimplemented <prefix:suffix />');
        break;
      case 2: // string
        view.appendText(ch[1]);
        break;
      case 3: 
        if (ch[2]) { // %%{xx}
          load_child_view_from_bind_data_vx(self, view, null, ch);
        } else { // %{xx}
          let exec = ch[1];
          let vx = exec(self.m_vdata, self);
          load_child_view(self, view, null, vx);
        }
        break;
      case 4: // ${xx}
        load_child_view(self, view, null, ch[1]);
        break;
      default: 
        throw new TypeError('Unknown view xml type');
        break;
    }
  }
  
  for (var attr of attrs) {
    set_attrbute(self, view, attr, register_view_data_bind);
  }
}

// -------------------- no ctr ----------------------

function set_attrbute_no_ctr(obj, attr_vx) {
  // [names,type,value]
  var [names,type,value] = attr_vx;
  var target = obj;
  var len = names.length - 1;
  var name = names[len];
  
  for (var i = 0; i < len; i++) {
    target = target[names[i]];
  }
  if (type === 0)  {
    target[name] = value;
  } else { // data bind
    throw new TypeError('Bad argument. Cannot bind data');
  }
}

function load_subctr_no_ctr(subctr, vx, parent) {
  var [,,attrs,childs,vdata] = vx;

  if (vdata) {
    set_attrbute_no_ctr(subctr, vdata);
  }
  
  if (childs.length) {
    subctr.loadView(...childs);
  } else {
    subctr.loadView(EMPTY_VIEW_XML);
  }
  
  var view = subctr.view;

  if (!view) {
    subctr.view = view = new View();
  }
  if (parent) {
    view.appendTo(parent);
  }

  for (var attr of attrs) {
    set_attrbute_no_ctr(subctr, attr);
  }
}

function load_view_no_ctr(view, vx) {
  var [,,attrs,childs] = vx;

  for (var ch of childs) {
    switch (ch[0]) {
      case 1: // <prefix:suffix />
        throw new TypeError('Unimplemented <prefix:suffix />');
        break;
      case 2: // string
        view.appendText(ch[1]);
        break;
      case 3: // %%{xx} or %{xx}
        throw new TypeError('Bad argument. Cannot bind data');
        break;
      case 4: // ${xx}
        ch = ch[1];
        if (Array.isArray(ch)) {
          if (ch[0] === 0) { // is view xml
            // goto case 0:
          } else if (ch[0] === 1) {
            throw new TypeError('Unimplemented <prefix:suffix />');
          } else if (ch[0] == 2) { // string
            view.appendText(ch[1]); break;
          } else {
            view.appendText(ch); break;
          }
        } else {
          view.appendText(ch); break;
        }
      case 0: // <tag />
        let tag = ch[1];
        let obj = new tag();
        if (obj instanceof ViewController) {
          load_subctr_no_ctr(obj, ch, view);
        } else { // view
          obj.appendTo(view);
          load_view_no_ctr(obj, ch);
        }
        break;
      default: 
        throw new TypeError('Unknown view xml type');
        break;
    }
  }

  for (var attr of attrs) {
    set_attrbute_no_ctr(view, attr);
  }
}

/**
 * @func New(vx[,parent[,...args]]) view or view controller with vx data
 * @func New(vx[,...args])
 * @arg vx {Object}
 * @arg [parent] {View}
 * @arg [...args]
 * @ret {View|ViewController}
 */
export function New(vx, parent, ...args) {
  if (isViewXml(vx)) {

    if ( parent ) {
      if ( !(parent instanceof View) ) {
        args.unshift(parent);
        parent = null;
      }
    }

    var [,tag] = vx;
    var rv = new tag(...args);
    var ctr = null;
    
    if ( parent ) {
      ctr = parent.ctr;
      if ( !ctr ) {
        if ( parent.top ) {
          ctr = parent.top.ctr;
        }
      }
    }
    
    if ( rv instanceof View ) {
      if ( parent ) {
        rv.appendTo(parent);
      }
      if ( ctr ) {
        load_view(ctr, rv, vx);
      } else {
        load_view_no_ctr(rv, vx);
      }
      return rv;
      
    } else if ( rv instanceof ViewController ) {
      if ( ctr ) {
        load_subctr(ctr, rv, vx, parent, null);
      } else {
        load_subctr_no_ctr(rv, vx, parent);
      }
      return rv;
    }

  }

  throw new TypeError('Bad argument. invalid view xml data');
}

 /**
  * @class NativeViewController
  * 
  * @get parent {ViewController}
  * 
  * @get,set view {View}
  *
  * @get,set id {uint}
  * 
  * @func find(id)
  * @arg id {String}
  * @ret {View|ViewController)
  *
  * @func remove()
  * 
  * @end
  */

/**
 * @class ViewController
 * @bases NativeViewController
 */
export class ViewController extends ngui.NativeViewController {

  m_vdata: null; // 视图数据
  m_proxys: null;

  /**
   * @event onViewDataChange
   */
  event onViewDataChange;
  
  /**
   * @event onLoadView
   */
  event onLoadView;
  
  /**
   * @event onRemoveView
   */
  event onRemoveView;
  
  /* proxy events */
  event onBack;
  event onClick;
  event onTouchstart;
  event onTouchmove;
  event onTouchend;
  event onTouchcancel;
  event onKeydown;
  event onKeypress;
  event onKeyup;
  event onKeyenter;
  event onFocus;
  event onBlur;
  event onHighlighted;
  event onFocusMove;
  event onScroll;  
  event onActionKeyframe;
  event onActionLoop;
  event onWaitBuffer; // player
  event onReady;
  event onStartPlay;
  event onError;
  event onSourceEOF;
  event onPause;
  event onResume;
  event onStop;
  event onSeek;
  
  /**
   * @get vdata {Object}
   */
  get vdata() { return this.m_vdata }

  /**
   * @set set vdata {Object}
   */
  set vdata(value) {
    if (typeof value == 'object') {
      util.extend(this.m_vdata, value);
      this.triggerViewDataChange();
    }
  }

  /**
   * @get view {View}
   */
  get view() { return super.view }

  /**
   * @set view {View}
   */
  set view(value) { 
    super.view = value;

    if ( this.__bind ) {
      if ( !this.__bind_id ) { // reset bind
        var parent = this.parent;
        if ( parent ) {
          register_subctr_data_bind(parent, this);
        }
      }
    }
  }

  /**
   * @constructor()
   */
  constructor() { 
    super();
    this.m_vdata = { };
  }
  
  /**
   * @func loadView(vx)
   * @arg vx {Object}
   */
  loadView(vx) {
    var [type, value] = vx;
    var view;

    switch(type) {
      case 0: // <tag />
        view = new value(); // 这里必需为视图，不可以为控制器
        this.view = view;
        load_view(this, view, vx);
        break;
      case 1: // <prefix:suffix />
        throw new TypeError('Unimplemented <prefix:suffix />');
        break;
      case 3: // %%{xx} or %{xx}
        let vx2 = value(this.m_vdata, this); // 数据绑定返回的数据必须都为元数据
        let tag = vx2[1];
        view = new tag(); // 这里必须为View
        this.view = view;
        load_view(this, view, vx2);
        if (vx[2]) { // multiple bind
          register_view_data_bind_with_replace(this, view, 2, vx);
        }
        break;
      case 4: // ${xx}
        if (Array.isArray(value)) { // view xml
          type = value[0];
          if (type === 0) {
            let tag = value[1];
            view = new tag(); // 这里必须为View
            this.view = view;
            load_view(this, view, value);
            break;
          } else if (type == 1) {
            throw new TypeError('Unimplemented <prefix:suffix />');
          } else if (type == 2) { // string
            value = value[1];
          }
        } // else string append text
      case 2: // string
        view = new Text();
        view.value = value;
        this.view = view;
        break;
      default: 
        throw new TypeError('Unknown view xml type');
        break;
    }

    // Reset proxy
    var proxys = this.m_proxys;
    if (proxys) { // unbind proxys
      for ( var name in proxys ) {
        add_proxy_event(this, name, self['__on' + name]);
      }
    }

    this.triggerLoadView();
  }

  /**
   * @get action {Action}
   */
  get action() { // get action object
    return this.view.action; 
  }
  
  /**
   * @set action {Action}
   */
  set action(value) { // set action
    this.view.action = value;
  }

  /**
   * @func transition(style[,delay[,cb]][,cb])
   * @arg style {Object}
   * @arg [delay] {uint} ms
   * @arg [cb] {Funcion}
   */
  transition(style, delay, cb) { // transition animate
    this.view.transition(style, delay, cb);
  }
  
  /**
   * @func show()
   */
  show() {
    this.view.show();
  }
  
  /**
   * @func show()
   */
  hide() {
    this.view.hide();
  }
  
  /**
   * @get class {Object}
   */
  get 'class'() { return this.view.class; }
  
  /**
   * @set class {String}
   */
  set 'class'(value) { this.view.class = value; }
  
  /**
   * @func addClass(name)
   * @arg name {String}
   */
  addClass(name) { this.view.addClass(name); }
  
  /**
   * @func removeClass(name)
   * @arg name {String}
   */
  removeClass(name) { this.view.removeClass(name); }
  
  /**
   * @func toggleClass(name)
   * @arg name {String}
   */
  toggleClass(name) { this.view.toggleClass(name); }
  
  /**
   * @get style {Object}
   */
  get style() { return this.view.style; }

  /**
   * @get style {Object}
   */
  set style(value) { this.view.style = value; }
  
  /**
   * @get visible {bool}
   */
  get visible() { return this.view.visible; }
  
  /**
   * @get visible {bool}
   */
  set visible(value) { this.view.visible = value; }
  
  /**
   * @get receive {bool}
   */
  get receive() { return this.view.receive; }
  
  /**
   * @get receive {bool}
   */
  set receive(value) { this.view.receive = value; }
  
  /**
   * @overwrite native call
   */
  triggerRemoveView(view) {
    util.assert(this.view === view);

    // remove bind
    var id = this.__bind_id;
    if ( id ) {
      unregister_data_bind(this.parent, id, this);
    }
    
    // unbind proxys
    var proxys = this.m_proxys;
    if (proxys) { 
      for ( var name in proxys ) {
        var id = proxys[name];
        if (id > 0) {
          var noticer = view['__on' + name]; //.off(name, id);
          if ( noticer ) {
            noticer.off(id);
          }
        }
        proxys[name] = 0;
      }
    }
    
    this.trigger('RemoveView', view);
  }

}

const proxy_events_table = {
  Keydown: 1, Keypress: 1, Keyup: 1, Keyenter: 1, Back: 1, Click: 1,
  Touchstart: 1, Touchmove: 1, Touchend: 1, Touchcancel: 1,
  Focus: 1, Blur: 1, Highlighted: 1, FocusMove: 1, Scroll: 1,
  ActionKeyframe: 1, ActionLoop: 1,
  WaitBuffer: 1, Ready: 1, StartPlay: 1, Error: 1,
  SourceEOF: 1, Pause: 1, Resume: 1, Stop: 1, Seek: 1,
};

function add_proxy_event(self, noticer, name) {

  if ( name in proxy_events_table ) { // proxy event
    var proxys = self.m_proxys;
    if (!proxys) {
      self.m_proxys = proxys = { };
    }
    
    var view = self.view;
    util.assert(view, 'View not found');
    
    var name2 = 'on' + name;

    if ( name2 in view ) { // 
      if ( !noticer ) {
        self['__on' + name] = noticer = new EventNoticer(name, this);
      }
      var trigger = self['trigger' + name];
      
      proxys[name] = view[name2].on((evt) => {
        var origin_noticer = evt.m_noticer;
        trigger.call(self, evt, 1);
        evt.m_noticer = origin_noticer;
      });

      return noticer;
    } else {
      proxys[name] = -1;
    }
  }
}

/**
 * @class ViewControllerNotification
 */
class ViewControllerNotification extends NativeNotification {
  
  // protected:
  /**
   * @overwrite
   */
  $getNoticer(name) {
    
    var noticer = this['__on' + name];
    if ( ! noticer ) {
      // bind native event

      noticer = add_proxy_event(this, noticer, name);
      if ( noticer ) {
        return noticer;
      }

      var trigger = this['trigger' + name];
      
      // bind native event
      if ( trigger ) {
        // bind native
        util.addNativeEventListener(this, name, (evt, is_event) => {
          // native event
          return trigger.call(this, evt, is_event);
        }, -1);
      } else {
        // bind native
        util.addNativeEventListener(this, name, (evt, is_event) => {
          // native event
          return is_event ? noticer.triggerWithEvent(evt) : noticer.trigger(evt);
        }, -1);
      }
      this['__on' + name] = noticer = new EventNoticer(name, this);
    } else {
      var proxys = this.m_proxys;
      if ( proxys && proxys[name] ) {
        return noticer;
      }
      add_proxy_event(this, noticer, name);
    }
    return noticer;
  }

  /**
   * @overwrite
   */
  $addDefaultListener(name, func) {
    
    if ( typeof func == 'string' ) {
      var ctr = this, func2;
      
      while (ctr) {
        func2 = ctr[func];  // find func
        if ( typeof func2 == 'function' ) {
          return this.$getNoticer(name).on(func2, ctr, 0); // default id 0
        }
        ctr = ctr.parent;
      }
      throw util.err(`Cannot find a function named "${func}"`);
    } else {
      return this.$getNoticer(name).on(func, 0); // default id 0
    }
  }
  
}

util.extendClass(ViewController, ViewControllerNotification);
